/*
 * generated by Xtext
 */
package org.xtext.example.xpt.generator;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xtext.example.xpt.xpt.Assertion;
import org.xtext.example.xpt.xpt.AssertionForm;
import org.xtext.example.xpt.xpt.AssertionSet;
import org.xtext.example.xpt.xpt.Declaration;
import org.xtext.example.xpt.xpt.Model;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

public class Main {

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;
	
	private static String xmlFilePath = "/home/ricky/Documenti/Code/XText/Workspace/org.xtext.example.xpt/src/org/xtext/example/xpt/book.xml";
	private static String queriesPath = "/home/ricky/Documenti/Code/XText/Workspace/org.xtext.example.xpt/src/org/xtext/example/xpt/queries.xpt";

	private static Map<String, Object> variables = new HashMap<String, Object>();

	public static void main(String[] args) {
		Injector injector = new org.xtext.example.xpt.XptStandaloneSetupGenerated().createInjectorAndDoEMFRegistration();
		Main main = injector.getInstance(Main.class);

		File f = new File(queriesPath);
		String string = f.toURI().toString();

		main.runGenerator(string);
	}

	protected void runGenerator(String string) {
		// load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createURI(string), true);

		// validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			System.err.println("*** MALFORMED ASSERTIONS ***");
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return;
		}

		// get contents
		Model model = (Model) resource.getContents().get(0);
		EObjectContainmentEList<Declaration> declarations = (EObjectContainmentEList<Declaration>) model.getDeclarations();
		AssertionSet assertionSet = model.getQuerySet();

		if (assertionSet.eContents().isEmpty()) {
			System.out.println("No assertions. Execution halted.");
			return;
		}

		System.out.println(declarations.size() + " variable declarated.");
		System.out.println(assertionSet.getAssertions().size() + " assertions has been found.");
		System.out.println();

		// get variables declaration and sets the hashmap
		setVariable(declarations);

		// verify the assertions
		verifyAssertions(assertionSet);

	}

	/**
	 * Check all the assertions
	 * 
	 * @param assertionSet
	 */
	private void verifyAssertions(AssertionSet assertionSet) {
		Object laObj, raObj;
		String op, condition;
		for (AssertionForm af : assertionSet.getAssertions()) {
			laObj = doQueries(af.getLeftAssert());
			raObj = doQueries(af.getRightAssert());
			op = af.getOp(); // get Op for using it for the comparisons
			condition = af.assertionFormConstruction(variables);

			// if the assertion's query has a numeric result
			if (laObj instanceof Double && raObj instanceof Double) {

				double la = (Double) laObj;
				double ra = (Double) raObj;
				switch (op) {
				case ">":
					if (la > ra) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}
					break;
				case ">=":
					if (la >= ra) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}
					break;
				case "<":
					if (la < ra) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}

					break;
				case "<=":
					if (la <= ra) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}
					break;
				case "=":
					if (la == ra) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}

					break;
				case "!=":
					if (la != ra) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}
					break;
				}
			} else if(laObj instanceof String && raObj instanceof String){
				String la = (String) laObj;
				String ra = (String) raObj;
				switch (op) {
				case "=":
					if (la.equals(ra)) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}

					break;
				case "!=":
					if (!la.equals(ra)) {
						System.out.println("Assertion '" + condition + "' is verified.");
					} else {
						System.out.println("Assertion '" + condition + "' is wrong.");
					}
					break;
				}
			} else {
				System.err.println("Assertion '" + condition + "' malformed: data types conflict.");
				return;
			}
		}
	}

	/**
	 * Print the result of the evaluation of queries
	 */
	private Object doQueries(Assertion assertion) {
		Object result = new Object();
		// if the assertion is a constant it's not going to be an xpath query
		if (assertion.getConstant() != null) {
			result = ((assertion.getConstant().getString() == null) ? assertion.getConstant().getInt() : assertion.getConstant().getString());
			return result;
		}
		String query = assertion.getQuery().queryConstruction(variables);
		NodeList results = getXMLResults(xmlFilePath, query);
		result = results.item(0).getTextContent(); //TODO sto trattando un solo valore! Non considera variabili multivalore
		if (assertion.getFunction() != null) {
			switch (assertion.getFunction()) {
				case "uppercase":
					result = ((String) result).toUpperCase();
					break;
				case "length":
					result = (double) ((String) result).length();
					break;
				default:
					break;
			}
		} else if (isNumeric((String) result)) { // check if the result is numeric and converts it to an integer
			result = Double.parseDouble((String) result);
		}
		return result;
	}

	/**
	 * Set the declarations and puts these in a map of variables
	 */
	private void setVariable(EObjectContainmentEList<Declaration> declarations) {
		for (Declaration d : declarations) {
			if (d.getAssert().getConstant() != null) {
				variables.put(d.getVar(), d.getAssert().getConstant());
			} else {
				variables.put(d.getVar(), d.getAssert().getQuery().queryConstruction(variables));
			}
		}
		return;
	}

	/**
	 * Make the evaluation of XPath queries
	 */
	private static NodeList getXMLResults(String filePath, String xpathQuery) {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder;
		try {
			builder = factory.newDocumentBuilder();
			Document doc = builder.parse(new File(filePath));
			doc.getDocumentElement().normalize();
			XPathFactory xPathfactory = XPathFactory.newInstance();
			XPath xpath = xPathfactory.newXPath();
			XPathExpression expr = xpath.compile(xpathQuery);
			NodeList nl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
			return nl;
		} catch (XPathExpressionException e) {
			e.printStackTrace();
		} catch (ParserConfigurationException e2) {
			e2.printStackTrace();
		} catch (SAXException | IOException e1) {
			e1.printStackTrace();
		}
		return null;
	}

	/**
	 * Check if a string is a number
	 * 
	 * @param str
	 * @return
	 */
	private static boolean isNumeric(String str) {
		try {
			@SuppressWarnings("unused")
			double d = Double.parseDouble(str);
		} catch (NumberFormatException nfe) {
			return false;
		}
		return true;
	}

//	/**
//	 * Translate to a string an XPath query
//	 */
//	private String genQuery(Query query) {
//		String res = "";
//		Attr attribute = null;
//		for (int i = 0; i < query.getSteps().size(); i++) {
//			if (query.getSteps().get(i).getPlaceholder() != null) {
//				res = (String) variables.get(query.getSteps().get(i).getPlaceholder());
//			} else {
//				res += '/' + query.getSteps().get(i).getName();
//				attribute = query.getSteps().get(i).getAttribute();
//				if (attribute != null) {
//					String property = attribute.getProperty();
//					String operation = attribute.getOp();
//					double value = attribute.getInt();
//					double intValue = attribute.getIntValue();
//					res += '[';
//					if (property != null && operation != null) {
//						res += property + operation;
//						if (attribute.getStrValue() != null) {
//							res += '"' + attribute.getStrValue() + '"' + ']';
//						} else {
//							res += String.valueOf(intValue) + ']';
//						}
//					} else {
//						res += String.valueOf(value) + ']';
//					}
//				}
//			}
//		}
//		return res;
//	}

	/**
	 * Translate to a string an XPath query, including the eventual associated
	 * function
	 */
	// private String genQueryForm(Assertion assertion) {
	// String res = genQuery(assertion.getQuery());
	// if (assertion.getFunction() != null) {
	// res += '.' + assertion.getFunction();
	// }
	// return res;
	// }

}
