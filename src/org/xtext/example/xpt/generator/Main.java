/*
 * generated by me
 */
package org.xtext.example.xpt.generator;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.SyntaxErrorMessage;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.xtext.example.xpt.generator.dataobject.DataObject;
import org.xtext.example.xpt.services.XptGrammarAccess.AssertionQuantifiedBooleanElements;
import org.xtext.example.xpt.services.XptGrammarAccess.AssertionQuantifiedNumericElements;
import org.xtext.example.xpt.xpt.Assertion;
import org.xtext.example.xpt.xpt.AssertionAnd;
import org.xtext.example.xpt.xpt.AssertionBraced;
import org.xtext.example.xpt.xpt.AssertionForm;
import org.xtext.example.xpt.xpt.AssertionNot;
import org.xtext.example.xpt.xpt.AssertionOr;
import org.xtext.example.xpt.xpt.AssertionQuantified;
import org.xtext.example.xpt.xpt.Assertions;
import org.xtext.example.xpt.xpt.Constant;
import org.xtext.example.xpt.xpt.Declaration;
import org.xtext.example.xpt.xpt.Function;
import org.xtext.example.xpt.xpt.Model;
import org.xtext.example.xpt.xpt.Query;
import org.xtext.example.xpt.xpt.Step;
import org.xtext.example.xpt.xpt.Value;
import org.xtext.example.xpt.xpt.Values;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

public class Main {

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	private static String queriesPath = "src/org/xtext/example/xpt/queries.xpt";
	private static String xmlFilePath = "src/org/xtext/example/xpt/book.xml";
	@SuppressWarnings("unused")
	private static String xmlFilePath2 = "src/org/xtext/example/xpt/book2.xml";

	private static Map<String, Object> variables = new HashMap<String, Object>();
	private static DataObject input = new DataObject();

	public static void main(String[] args) {
		Injector injector = new org.xtext.example.xpt.XptStandaloneSetupGenerated().createInjectorAndDoEMFRegistration();
		Main main = injector.getInstance(Main.class);

		File f = new File(queriesPath);
		String string = f.toURI().toString();

		main.runGenerator(string);
	}

	@SuppressWarnings("unused")
	private DataObject hashMapTest() {
		DataObject data = new DataObject();
		DataObject books = new DataObject();
		DataObject book1 = new DataObject();
		DataObject book2 = new DataObject();

		// book1.put("title", "Snow Crash");
		// book1.put("year", (double) 2000);
		// book1.put("author", "Neal Stephenson");
		// book1.put("publisher", "Spectra");
		// book1.put("isbn", "0553380958");
		// book1.put("price", (double) 15.0);
		// books.put("book", book1);
		//
		// book2.put("title", "Burning Tower");
		// book2.put("year", (double) 2005);
		book2.put("author", "Larry Niven");
		book2.put("author", "Jerry Pournelle");
		// book2.put("publisher", "Pocket");
		// book2.put("isbn", "0743416910");
		// book2.put("price", (double) 5.99);
		// books.put("book", book2);

		// books.put("book", (double) 5);

		data.put("inventory", book2);

		return data;
	}

	protected void runGenerator(String string) {
		// load the resource and parse it
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createURI(string), true);

		// check for syntax errors
		if (syntaxErrors(resource)) {
			return;
		}

		// get contents
		Model model = (Model) resource.getContents().get(0);
		EObjectContainmentEList<Declaration> declarations = (EObjectContainmentEList<Declaration>) model.getDeclarations();
		Assertions assertionSet = model.getAssertionSet();

		// number of assertions
		int count = 0;
		TreeIterator<EObject> a = assertionSet.eAllContents();
		if (assertionSet instanceof AssertionForm) {
			count = count + 1;
		}
		while (a.hasNext()) {
			EObject next = a.next();
			if (next instanceof AssertionForm) {
				count = count + 1;
			}
		}

		// get input: via xml parsing or passed DataObject
		input = new DataObject(xmlFilePath);
		// input = hashMapTest(); // load input from a DataObject

		// print out the DataObject conversion of the XML file
		System.out.println("################## INPUT ###################\n" + input + "\n");

		if (count == 0) {
			System.out.println("No assertions. Execution halted.");
			return;
		}

		System.out.println("################## RULES ###################");
		System.out.println(declarations.size() + " variable declarated.");
		System.out.println(count + " assertions has been found.\n");

		// get variables declaration and sets the hashmap
		try {
			setVariable(declarations);
		} catch (Exception e) {
			System.err.println("\n**** RUNTIME ERRORS ****\n" + e.getMessage());
			System.exit(0);
		}

		// verify the assertions
		System.out.println("\n################ ASSERTIONS ################");
		try {
			System.out.println("\nRESULT: " + verifyAssertions(assertionSet));
		} catch (Exception e) {
			System.err.println("\n**** RUNTIME ERRORS ****\n" + e.getMessage());
			System.exit(0);
		}

	}

	/**
	 * Syntax error checking, with information about the error (an error message, the line number of the error and wrong token)
	 * 
	 * @param resource the result of the parsed rules
	 * @return <code>true</code> if there is errors, <code>false</code> otherwise
	 */
	private boolean syntaxErrors(Resource resource) {
		// syntax errors checking
		Iterable<INode> errors = ((XtextResource) resource).getParseResult().getSyntaxErrors();
		Iterator<INode> iter = errors.iterator();
		int number = resource.getErrors().size();

		if (number == 0) { // no errors, go away!
			return false;
		}

		System.err.println("**** MALFORMED ASSERTIONS ****\n*** " + number + " syntax errors found ***\n");

		INode errorNode = null;
		while (iter.hasNext()) {
			errorNode = iter.next();
			ICompositeNode parent = errorNode.getParent();
			EObject semanticElement = errorNode.getSemanticElement();
			int sl = errorNode.getStartLine();
			SyntaxErrorMessage errm = errorNode.getSyntaxErrorMessage();
			String erroneousToken = "";
			if (semanticElement instanceof AssertionForm) {
				erroneousToken = Helper.assertionFormToString((AssertionForm) semanticElement);
			} else if (semanticElement instanceof Assertion) {
				erroneousToken = Helper.assertionToString((Assertion) semanticElement);
			} else if (semanticElement instanceof Declaration) {
				erroneousToken = Helper.declarationToString((Declaration) semanticElement);
			} else if (semanticElement instanceof Query) {
				erroneousToken = Helper.queryToString((Query) semanticElement);
			} else if (semanticElement instanceof Step) {
				erroneousToken = Helper.stepToString((Step) semanticElement);
			} else {
				EObject parentSemanticElement = parent.getSemanticElement();
				while (erroneousToken.equals("")) {
					if (parentSemanticElement instanceof AssertionForm) {
						erroneousToken = Helper.assertionFormToString((AssertionForm) parentSemanticElement);
					} else if (parentSemanticElement instanceof Assertion) {
						erroneousToken = Helper.assertionToString((Assertion) parentSemanticElement);
					} else if (parentSemanticElement instanceof Declaration) {
						erroneousToken = Helper.declarationToString((Declaration) parentSemanticElement);
					} else if (parentSemanticElement instanceof Query) {
						erroneousToken = Helper.queryToString((Query) parentSemanticElement);
					} else if (parentSemanticElement instanceof Step) {
						erroneousToken = Helper.stepToString((Step) parentSemanticElement);
					} else {
						if (parentSemanticElement.eContainer() != null) {
							parentSemanticElement = parentSemanticElement.eContainer();
						} else { // we are in the root node
							erroneousToken = "ROOT";
						}
					}
				}
			}
			System.err.println("ERROR: " + errm.getMessage() + " - line: " + sl + " - token: '" + erroneousToken + "'");

			// "table-formatted" output
			// System.err.printf("%-60s - %-8s - %-60s %n", "ERROR: " + errm.getMessage(), "line: " + sl, "token: " + erroneousToken);
		}
		return true;
	}

	/**
	 * Syntax errors checking with the validator of the grammar
	 * 
	 * @param resource the result of the parsed rules
	 * @return <code>true</code> if there is errors, <code>false</code> otherwise
	 */
	//TODO valuta se eliminabile
	@SuppressWarnings("unused")
	private boolean checkSyntaxErrorValidator(Resource resource) {
		// validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			System.err.println("*** MALFORMED ASSERTIONS ***");
			for (Issue issue : list) {
				URI problemURI = issue.getUriToProblem();
				String location = problemURI.fragment();
				String msg = issue.getMessage();
				Integer lineNumb = issue.getLineNumber();
				// Print out syntax errors
				System.err.println("ERROR:" + msg + " - line: " + lineNumb + " - token: '" + location + "'");
			}
			return true;
		}
		return false;
	}

	/**
	 * Method for the evaluation of the {@link Assertions}, considering the operation (NOT, AND, OR) and the corresponding priority (NOT>AND>OR)
	 * 
	 * @param assertions the list of {@link Assertions} to evaluate
	 * @return <code>true</code> if the {@link Assertions} are respected, <code>false</code> otherwise
	 * @throws Exception if there are exception (caused by runtime errors) from the single {@link Assertions}
	 */
	public boolean verifyAssertions(Assertions assertions) throws Exception {
		EList<EObject> a = assertions.eContents();
		if (assertions instanceof AssertionAnd) {
			return (verifyAssertions((Assertions) a.get(0)) & verifyAssertions((Assertions) a.get(1)));
		} else if (assertions instanceof AssertionOr) {
			return (verifyAssertions((Assertions) a.get(0)) | verifyAssertions((Assertions) a.get(1)));
		} else if (assertions instanceof AssertionNot) {
			return !verifyAssertions(((AssertionNot) assertions).getInnerFormula());
		} else if (assertions instanceof AssertionBraced) {
			return verifyAssertions(((AssertionBraced) assertions).getInnerFormula());
		} else if (assertions instanceof AssertionQuantified) {
			return false;
		} else if (assertions instanceof AssertionForm) {
			return verifyAssertionForm((AssertionForm) assertions);
		}
		return false;
	}

	/**
	 * Check an {@link AssertionForm}, in its various forms
	 * 
	 * @param af the {@link AssertionForm} to check
	 * @return <code>true</code> if the {@link AssertionForm} is verified, <code>false</code> otherwise 
	 * @throws Exception if there is data types conflicts, specifying the cause of the error and the erroneous values 
	 * @throws Exception if there is a generic runtime error, specified with a proper message
	 */
	private boolean verifyAssertionForm(AssertionForm af) throws Exception {
		Object laObj, raObj;
		String operation;

		laObj = doQueries(af.getLeftAssert());

		// check if the AssertionForm is of type AssertionQualifiedBoolean (so without the '= true' explicitly specified)
		if (af.getOp() == null && af.getRightAssert() == null) {
			operation = "==";
			raObj = true;
		} else {
			operation = af.getOp(); // get Op for using it for the comparisons
			raObj = doQueries(af.getRightAssert());
		}

		String assertionRepr = Helper.assertionFormToString(af);

		// check the objects class and evaluate the corresponding assertion
		if (laObj instanceof Double && raObj instanceof Double) {
			return numericAssertion((double) laObj, (double) raObj, operation, assertionRepr);
		} else if (laObj instanceof String && raObj instanceof String) {
			return stringAssertion((String) laObj, (String) raObj, operation, assertionRepr);
		} else if (laObj instanceof DataObject && raObj instanceof DataObject) {
			return dataobjectAssertion((DataObject) laObj, (DataObject) raObj, operation, assertionRepr);
		} else if (laObj instanceof Boolean && raObj instanceof Boolean) {
			return booleanAssertion((boolean) laObj, (boolean) raObj, operation, assertionRepr);
		} else if (laObj != null && raObj != null) {
			String msg = "Assertion could not be evaluated due to data types conflicts [token: '" + assertionRepr + "']";
			msg += "\n Left assertion [token: '" + Helper.assertionToString(af.getLeftAssert()) + "'] = " + laObj + " (Class: " + laObj.getClass().getSimpleName() + ")";
			msg += "\n Right assertion [token: '" + Helper.assertionToString(af.getRightAssert()) + "'] = " + raObj + " (Class: " + raObj.getClass().getSimpleName() + ")";
			throw new Exception(msg);
		} else {
			throw new Exception("Unable to evaluate the assertion, due to erroneous variables declaration [token: '" + assertionRepr + "']");
		}
	}

	/**
	 * Method for the evaluation of numeric {@link AssertionForm}
	 * 
	 * @param left the result of the left part of the {@link AssertionForm}
	 * @param right the result of the right part of the {@link AssertionForm}
	 * @param operation a {@link String} containing the operation to evaluate
	 * @param condition a {@link String} representation of the {@link AssertionForm}
	 * @return <code>true</code> if the {@link AssertionForm} is verified, <code>false</code> otherwise
	 * @throws Exception if the operation is not supported
	 */
	private boolean numericAssertion(double left, double right, String operation, String condition) throws Exception {
		boolean result;
		switch (operation) {
		case ">":
			if (left > right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case ">=":
			if (left >= right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "<":
			if (left < right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "<=":
			if (left <= right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "==":
			if (left == right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "!=":
			if (left != right) {
				result = true;
			} else {
				result = false;
			}
			break;
		default:
			String msg = "Unsopported operation '" + operation + "' for the assertion between two String [token: '" + condition + "']";
			msg += "\n Left assertion = '" + left + "' ";
			msg += "\n Right assertion = '" + right + "' ";
			throw new Exception(msg);
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Method for the evaluation of string {@link AssertionForm}
	 * 
	 * @param left the result of the left part of the {@link AssertionForm}
	 * @param right the result of the right part of the {@link AssertionForm}
	 * @param operation a {@link String} containing the operation to evaluate
	 * @param condition a {@link String} representation of the {@link AssertionForm}
	 * @return <code>true</code> if the {@link AssertionForm} is verified, <code>false</code> otherwise
	 * @throws Exception if the operation is not supported
	 */
	private boolean stringAssertion(String left, String right, String operation, String condition) throws Exception {
		boolean result;
		switch (operation) {
		case "==":
			if (left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "!=":
			if (!left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		default:
			String msg = "Unsopported operation '" + operation + "' for the assertion between two String [token: '" + condition + "']";
			msg += "\n Left assertion = '" + left + "' ";
			msg += "\n Right assertion = '" + right + "' ";
			throw new Exception(msg);
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Method for the evaluation of boolean {@link AssertionForm}
	 * 
	 * @param left the result of the left part of the {@link AssertionForm}
	 * @param right the result of the right part of the {@link AssertionForm}
	 * @param operation a {@link String} containing the operation to evaluate
	 * @param condition a {@link String} representation of the {@link AssertionForm}
	 * @return <code>true</code> if the {@link AssertionForm} is verified, <code>false</code> otherwise
	 * @throws Exception if the operation is not supported
	 */
	private boolean booleanAssertion(boolean left, boolean right, String operation, String condition) throws Exception {
		boolean result;
		switch (operation) {
		case "==":
			result = left == right;
			break;
		case "!=":
			result = left != right;
			break;
		default:
			String msg = "Unsopported operation '" + operation + "' for the assertion between two Boolean [token: '" + condition + "']";
			msg += "\n Left assertion = '" + left + "' ";
			msg += "\n Right assertion = '" + right + "' ";
			throw new Exception(msg);
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Method for the evaluation of DataObject {@link AssertionForm}
	 * 
	 * @param left the result of the left part of the {@link AssertionForm}
	 * @param right the result of the right part of the {@link AssertionForm}
	 * @param operation a {@link String} containing the operation to evaluate
	 * @param condition a {@link String} representation of the {@link AssertionForm}
	 * @return <code>true</code> if the {@link AssertionForm} is verified, <code>false</code> otherwise
	 * @throws Exception if the operation is not supported
	 */
	private boolean dataobjectAssertion(DataObject left, DataObject right, String operation, String condition) throws Exception {
		boolean result;
		switch (operation) {
		case "==":
			if (left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "!=":
			if (!left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		default:
			String msg = "Unsopported operation '" + operation + "' for the assertion between two DataObject [token: '" + condition + "']";
			msg += "\n Left assertion = '" + left + "' ";
			msg += "\n Right assertion = '" + right + "' ";
			throw new Exception(msg);
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Returns the result of a single {@link Assertion}, considering also the applied functions
	 * 
	 * @param assertion the {@link Assertion} to evaluate
	 * @return an {@link Object} corresponding to the result of the evaluation
	 * @throws Exception if is used an undefined variable for the {@link Assertion} specification 
	 * @throws Exception if the evaluation goes wrong, the cause will be specified with a message
	 */
	private Object doQueries(Assertion assertion) throws Exception {

		if (assertion instanceof AssertionQuantified) {
			return doAssertionQuantified(assertion);
		}

		Object result = new Object();
		// if the assertion is a constant it's not going to be an xpath query
		if (assertion.getConstant() != null) {
			return ((assertion.getConstant().getString() == null) ? assertion.getConstant().getNumber() : assertion.getConstant().getString());
		}
		// look if there's a placeholder, if any substitute it with its values (note: the placeholder is always on the first step!)
		if (assertion.getQuery() != null) {
			String placeholder = assertion.getQuery().getSteps().get(0).getPlaceholder();

			if (placeholder != null) {
				if (!variables.containsKey(placeholder)) {
					throw new Exception("Variable '" + placeholder + "' is not defined [token: '" + Helper.assertionToString(assertion) + "']");
				}
				Object value = variables.get(placeholder);
				if (value instanceof DataObject) {
					if (assertion.getQuery().getSteps().size() > 1) { // if there query goes deeper
						result = ((DataObject) value).evaluate(assertion.getQuery());
						if (((DataObject) result).isSingleValue()) {
							result = ((DataObject) result).getFirstValue();
						}
					} else {
						if (((DataObject) value).isSingleValue()) {
							result = ((DataObject) value).getFirstValue();
						} else {
							result = value;
						}
					}
				} else {
					result = value;
				}
			} else {
				result = input.evaluate(assertion.getQuery());
				// if the DataObject is containing a single value it will be extrapolated from the Object
				if (((DataObject) result).isSingleValue()) {
					result = ((DataObject) result).getFirstValue();
				}
			}
		} else {
			result = assertion.isBoolean();
		}

		// functions evaluation, according to the corresponding type
		EList<Function> functions = assertion.getFunction();
		if (functions != null) {
			for (Function f : functions) {
				if (result instanceof DataObject) {
					result = applyDataObjectFunctions(result, f, Helper.assertionToString(assertion));
				} else if (result instanceof String) {
					result = applyStringFunctions(result, f, Helper.assertionToString(assertion));
				} else if (result instanceof Double) {
					result = applyDoubleFunctions(result, f, Helper.assertionToString(assertion));
				}
			}
		}
		return result;
	}

	/**
	 * Returns the result of an {@link AssertionQuantified}.
	 * {@link AssertionQuantified} are of two types: {@link AssertionQuantifiedNumericElements} if the result is of type {@link Double}
	 *  and {@link AssertionQuantifiedBooleanElements} if the result is of type {@link Boolean}
	 * 
	 * @param assertion the {@link AssertionQuantified} to evaluate
	 * @return a boolean if the assertion is a {@link AssertionQuantifiedBooleanElements}, otherwise a double in the case of {@link AssertionQuantifiedNumericElements}
	 * @throws Exception if the selected variable is not of {@link DataObject} type
	 * @throws Exception if the chosen variable alias is already used
	 * @throws Exception if the variable is not defined
	 * @throws Exception if the variable is not of the correct type regarding to the quantifier
	 */
	private Object doAssertionQuantified(Assertion assertion) throws Exception {
		AssertionQuantified aq = (AssertionQuantified) assertion;
		String assertionRepr = "[token: '" + Helper.assertionQuantifiedToString(aq) + "']";

		if (!(variables.containsKey(aq.getVar()))) {
			throw new Exception("The variable '" + aq.getVar() + "' is not defined. " + assertionRepr);

		}

		if (!(variables.get(aq.getVar()) instanceof DataObject)) {
			throw new Exception("Could not iterate over a " + variables.get(aq.getVar()).getClass().getSimpleName() + " (" + aq.getVar() + "). A DataObject type was expected " + assertionRepr);
		}

		DataObject set = (DataObject) variables.get(aq.getVar());
		String alias = aq.getAlias();
		boolean result;
		double count, sum;

		if (variables.containsKey(alias)) {
			throw new Exception("The variable '" + alias + "' is already used. Choose another. " + assertionRepr);
		}

		Iterator<Object> iter = set.values().iterator();

		switch (aq.getQuantifier()) {
		case "forall":
			while (iter.hasNext()) {
				variables.put(alias, iter.next());
				result = verifyAssertions(aq.getConditions());
				if (!result) {
					variables.remove(alias);
					return false;
				}
			}
			return true;
		case "exists":
			result = false;
			while (iter.hasNext()) {
				variables.put(alias, iter.next());
				result = result | verifyAssertions(aq.getConditions());
			}
			variables.remove(alias);
			return true;
		case "numOf":
			count = 0;
			while (iter.hasNext()) {
				variables.put(alias, iter.next());
				if (verifyAssertions(aq.getConditions())) {
					count = count + 1;
				}
			}
			variables.remove(alias);
			return count;
		case "sum":
			sum = 0;
			while (iter.hasNext()) {
				Object next = iter.next();
				if (!(next instanceof Double)) {
					throw new Exception("The variable '" + aq.getVar() + "' contains an element of class '" + next.getClass().getSimpleName() + "'. Only Doubles are accepted by '" + aq.getQuantifier() + "' function " + assertionRepr);
				}
				variables.put(alias, next);
				if (verifyAssertions(aq.getConditions())) {
					sum += (double) next;
				}
			}
			variables.remove(alias);
			return sum;
		case "avg":
			sum = 0;
			count = 0;
			while (iter.hasNext()) {
				Object next = iter.next();
				if (!(next instanceof Double)) {
					throw new Exception("The variable '" + aq.getVar() + "' contains an element of class '" + next.getClass().getSimpleName() + "'. Only Doubles are accepted by '" + aq.getQuantifier() + "' function " + assertionRepr);
				}
				variables.put(alias, next);
				if (verifyAssertions(aq.getConditions())) {
					sum += (double) next;
					count += 1;
				}
			}
			variables.remove(alias);
			return sum / count;
		case "product":
			double product = 1;
			while (iter.hasNext()) {
				Object next = iter.next();
				if (!(next instanceof Double)) {
					throw new Exception("The variable '" + aq.getVar() + "' contains an element of class '" + next.getClass().getSimpleName() + "'. Only Doubles are accepted by '" + aq.getQuantifier() + "' function " + assertionRepr);
				}
				variables.put(alias, next);
				if (verifyAssertions(aq.getConditions())) {
					product *= (double) next;
				}
			}
			variables.remove(alias);
			return product;
		case "max":
			double max = Double.NEGATIVE_INFINITY;
			while (iter.hasNext()) {
				Object next = iter.next();
				if (!(next instanceof Double)) {
					throw new Exception("The variable '" + aq.getVar() + "' contains an element of class '" + next.getClass().getSimpleName() + "'. Only Doubles are accepted by '" + aq.getQuantifier() + "' function " + assertionRepr);
				}
				variables.put(alias, next);
				if (verifyAssertions(aq.getConditions())) {
					if ((double) next > max) {
						max = (double) next;
					}
				}
			}
			variables.remove(alias);
			return max;
		case "min":
			double min = Double.POSITIVE_INFINITY;
			while (iter.hasNext()) {
				Object next = iter.next();
				if (!(next instanceof Double)) {
					throw new Exception("The variable '" + aq.getVar() + "' contains an element of class '" + next.getClass().getSimpleName() + "'. Only Doubles are accepted by '" + aq.getQuantifier() + "' function " + assertionRepr);
				}
				variables.put(alias, next);
				if (verifyAssertions(aq.getConditions())) {
					if ((double) next < min) {
						min = (double) next;
					}
				}
			}
			variables.remove(alias);
			return min;
		default:
			return null; // never reached: other cases are blocked by the grammar parser as errors
		}
	}

	/**
	 * List of functions for the String results from an {@link Assertion} evaluation
	 * 
	 * @param object the String the elaborate
	 * @param function the {@link Function} to apply
	 * @return the result of the function
	 * @throws Exception if the number of parameter is wrong, according to the function, and prints out the expected number
	 * @throws Exception if the type of parameter is wrong, according to the function, and prints out the value and the expected type
	 */
	private Object applyStringFunctions(Object object, Function function, String assertionRep) throws Exception {
		List<Object> params = getFunctionParams(function, assertionRep);
		switch (function.getName()) {
		case "uppercase":
			if (params == null) {
				return ((String) object).toUpperCase();
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 0) [token: '" + assertionRep + "']");
			}
		case "length":
			if (params == null) {
				return (double) ((String) object).length();
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 0) [token: '" + assertionRep + "']");
			}
		case "startsWith":
			if (params != null && params.size() == 1) {
				if (params.get(0) instanceof String) {
					return ((String) object).startsWith((String) params.get(0));
				} else {
					throw new Exception("Wrong type of parameter (" + params.get(0).getClass().getSimpleName() + " instead of a string) [token: '" + assertionRep + "']");
				}
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 1) [token: '" + assertionRep + "']");
			}
		case "endsWith":
			if (params != null && params.size() == 1) {
				if (params.get(0) instanceof String) {
					return ((String) object).endsWith((String) params.get(0));
				} else {
					throw new Exception("Wrong type of parameter (" + params.get(0).getClass().getSimpleName() + " instead of a string) [token: '" + assertionRep + "']");
				}
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 1) [token: '" + assertionRep + "']");
			}
		case "substring":
			if (params != null && params.size() == 2) {
				if (params.get(0) instanceof Double && params.get(1) instanceof Double) {
					int beginIndex, endIndex;
					if (Math.rint((double) params.get(0)) == (double) params.get(0)) {
						beginIndex = (int) ((double)params.get(0));
					} else {
						throw new Exception("The first parameter in function '" + function.getName() + "' is not of type Int. [token: '" + assertionRep + "']");
					}
					if (Math.rint((double) params.get(1)) == (double) params.get(1)) {
						endIndex = (int) ((double)params.get(1));
					} else {
						throw new Exception("The second parameter in function '" + function.getName() + "' is not of type Int. [token: '" + assertionRep + "']");
					}
					return ((String) object).substring(beginIndex, endIndex);
				} else {
					throw new Exception("Wrong type of parameter (" + params.get(0).getClass().getSimpleName() + " and " + params.get(1).getClass().getSimpleName() + " instead of two numbers) [token: '" + assertionRep + "']");
				}
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 2) [token: '" + assertionRep + "']");
			}
		case "replace":
			if (params != null && params.size() == 2) {
				if (params.get(0) instanceof String && params.get(1) instanceof String) {
					return ((String) object).replace((String)params.get(0), (String)params.get(1));
				} else {
					throw new Exception("Wrong type of parameter (" + params.get(0).getClass().getSimpleName() + " and " + params.get(1).getClass().getSimpleName() + " instead of two String) [token: '" + assertionRep + "']");
				}
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 2) [token: '" + assertionRep + "']");
			}
		default:
			return null;
		}
	}

	/**
	 * List of functions for the numeric results from an {@link Assertion} evaluation
	 * 
	 * @param object the number (type {@link Double}) the elaborate
	 * @param function the {@link Function} to apply
	 * @return the result of the function
	 * @throws Exception if the number of parameter is wrong, according to the function, and prints out the expected number
	 */
	private Object applyDoubleFunctions(Object object, Function function, String assertionRep) throws Exception {
		List<Object> params = getFunctionParams(function, assertionRep);
		switch (function.getName()) {
		case "abs":
			if (params == null) {
				return Math.abs((double) object);
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 2) [token: '" + assertionRep + "']");
			}
		case "length":
			if (params == null) {
				return (double) String.valueOf((double) object).length();
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 2) [token: '" + assertionRep + "']");
			}
		default:
			return null;
		}
	}

	/**
	 * List of functions for the {@link DataObject} results from an {@link Assertion} evaluation
	 * 
	 * @param object the {@link DataObject} the elaborate
	 * @param function the {@link Function} to apply
	 * @return the result of the function
	 * @throws Exception if the number of parameter is wrong, according to the function, and prints out the expected number
	 */
	// TODO add other functions
	private Object applyDataObjectFunctions(Object object, Function function, String assertionRep) throws Exception {
		List<Object> params = getFunctionParams(function, assertionRep);
		switch (function.getName()) {
		case "contains":
			if(((DataObject)object).isEmpty()) {
				throw new Exception("Function '" + function.getName() + "' could not be applied because the DataObject is empty [token: '" + assertionRep + "']"); 
			}
			if (params.size() == 1) {
				return ((DataObject) object).contains(params.get(0));
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 1) [token: '" + assertionRep + "']");
			}
		case "get":
			if(((DataObject)object).isEmpty()) {
				throw new Exception("Function '" + function.getName() + "' could not be applied because the DataObject is empty [token: '" + assertionRep + "']"); 
			}
			if(params.size() == 1) {
				if(params.get(0) instanceof String) {
					return ((DataObject) object).get((String) params.get(0));
				} else if(params.get(0) instanceof Double) {
					return ((DataObject) object).get((int)(double)params.get(0));
				}
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 1) [token: '" + assertionRep + "']");
			}
		case "cardinality":
			if(params == null) {
				return ((DataObject) object).size();
			} else {
				throw new Exception("Wrong number of parameters for function '" + function.getName() + "' (" + params.size() + " instead of 0) [token: '" + assertionRep + "']");
			}
		default:
			break;
		}
		return null;
	}

	/**
	 * Given the function extract the parameters (resolving the ones related to a variable) and returns a 
	 * list of value (of different type: {@link String}, {@link Double}, {@link Boolean} or {@link DataObject})
	 * 
	 * @param function the {@link Function} to elaborate
	 * @return the list of value
	 * @throws Exception if the variable (if present) it's not defined
	 */
	private List<Object> getFunctionParams(Function function, String assertionRep) throws Exception {
		if (function.getParams() != null) {
			List<Object> params = new ArrayList<Object>();
			for (Value v : function.getParams().getValue()) {
				if (v.getVar() != null) {
					if (variables.containsKey(v.getVar())) {
						params.add(variables.get(v.getVar()));
					} else {
						throw new Exception("Variable '" + v.getVar() + "' is not defined [token: '" + assertionRep + "']");
					}
				} else if (v instanceof Constant) {
					if (((Constant) v).getString() != null) {
						params.add(((Constant) v).getString());
					} else {
						params.add(((Constant) v).getNumber());
					}
				} else {
					params.add(v);
				}
			}
			return params;
		} else {
			return null;
		}
	}

	/**
	 * Set variables according to the {@link Declaration}.
	 * Evaluates the query, resolves the variables, translate {@link Values} into {@link DataObject}, extract correct value from a {@link Constant} and assigns the values to a key with the specified name
	 * The values are extracted and saved as simple type ({@link String}, {@link Double} and {@link Boolean}) if the results of an evaluation is a {@link DataObject} with a single value. Otherwise as a {@link DataObject}.  
	 * 
	 * @param declarations the list of {@link Declaration} rules parsed
	 * @throws Exception if the variable is already in use
	 * @throws Exception if a variable, used inside a declaration and on which that is based, is not defined 
	 * @throws Exception if the evaluation goes wrong, the cause will be specified 
	 * @throws Exception if the evaluation gives back an empty result
	 */
	private void setVariable(EObjectContainmentEList<Declaration> declarations) throws Exception {
		Object result = null;
		System.out.println("############### DECLARATIONS ###############");
		for (Declaration d : declarations) {
			String assertionRep = Helper.declarationToString(d);
			if (variables.containsKey(d.getVar())) {
				throw new Exception("The variable '" + d.getVar() + "' in '" + Helper.declarationToString(d) + "' is already used (" + d.getVar() + " = " + variables.get(d.getVar()) + "). Choose another [token: '" + assertionRep + "']");
			}
			if (d.getAssert().getConstant() != null) {
				if (d.getAssert().getConstant().getString() != null) {
					result = d.getAssert().getConstant().getString();
				} else {
					result = d.getAssert().getConstant().getNumber();
				}
			} else if (d.getAssert().getValues() != null) {
				List<Object> values = new ArrayList<Object>();
				for (Value v : d.getAssert().getValues().getValue()) {
					if (v.getVar() != null) {
						if (variables.containsKey(v.getVar())) {
							values.add(variables.get(v.getVar()));
						} else {
							throw new Exception("Variable '" + v.getVar() + "' is not defined [token: '" + assertionRep + "']");
						}
					} else if (v instanceof Constant) {
						if (((Constant) v).getString() != null) {
							values.add(((Constant) v).getString());
						} else {
							values.add(((Constant) v).getNumber());
						}
					} else {
						values.add(v);
					}
				}
				result = new DataObject(d.getVar(), values);
			} else if (d.getAssert().getQuery() != null) {
				String placeholder = d.getAssert().getQuery().getSteps().get(0).getPlaceholder();

				if (placeholder != null) {
					if (!variables.containsKey(placeholder)) {
						throw new Exception("Variable '" + placeholder + "' is not defined [token: '" + assertionRep + "']");
					}

					Object value = variables.get(placeholder);
					if (value instanceof DataObject) {
						if (d.getAssert().getQuery().getSteps().size() > 1) { // if there query goes deeper
							try {
								result = ((DataObject) value).evaluate(d.getAssert().getQuery());
							} catch (Exception e) {
								throw new Exception("Unable to evaluate the declaration. Please check it [token: '" + assertionRep + "']\n" + " CAUSE: " + e.getMessage());
							}
							// if the DataObject is containing a single value, only that single value is stored as variable
							if (((DataObject) result).isSingleValue()) {
								result = ((DataObject) result).getFirstValue();
							}
						} else {
							// if (((DataObject) value).isSingleValue()) {
							// result = ((DataObject) value).getFirst();
							// } else {
							result = value;
							// }
						}
					} else {
						result = value;
					}
				} else {
					try {
						result = input.evaluate(d.getAssert().getQuery());
					} catch (Exception e) {
						throw new Exception("Unable to evaluate the declaration. Please check it [token: '" + assertionRep + "']\n" + " CAUSE: " + e.getMessage());
					}
					if (((DataObject) result).isSingleValue()) {
						result = ((DataObject) result).getFirstValue();
//					} else if(((DataObject)result).isEmpty()) { // if the result is empty
//						throw new Exception("The declaration gives empty result. Please check it [token: '" + assertionRep + "']");
//						//TODO alternativamente il problema viene segnalato e la variabile non viene dichiarata, se verrà usata successivamente scatterà l'eccezione in quanto non definita
					}
				}

				// *** FUNCTIONS ***
				EList<Function> functions = d.getAssert().getFunction();
				if (functions != null) {
					for(Function f:functions){
						if (result instanceof DataObject) {
							result = applyDataObjectFunctions(result, f, Helper.assertionToString(d.getAssert()));
						} else if (result instanceof String) {
							result = applyStringFunctions(result, f, Helper.assertionToString(d.getAssert()));
						} else if (result instanceof Double) {
							result = applyDoubleFunctions(result, f, Helper.assertionToString(d.getAssert()));
						}
					}
				}

			} else if (d.getAssert() instanceof AssertionQuantified) {
				result = doAssertionQuantified(d.getAssert());
			} else {
				result = d.getAssert().isBoolean();
			}

			variables.put(d.getVar(), result);
			System.out.println(Helper.declarationToString(d));
		}
		return;
	}
	
//	private void throwError(String msg, Object element) throws Exception{
//		String prefix = "RUNTIME ERROR: ";
//		String location = "";
//		
//		if(element instanceof Assertions){
//			location = Helper.assertionsToString((Assertions) element);
//		} else if(element instanceof AssertionQuantified) {
//			location = Helper.assertionQuantifiedToString((AssertionQuantified) element);
//		} else if(element instanceof AssertionForm) {
//			location = Helper.assertionFormToString((AssertionForm) element);
//		} else if(element instanceof Assertion) {
//			location = Helper.assertionToString((Assertion) element);
//		}
//		msg = msg.replace("#", "[" + location + "]");
//		throw new Exception(prefix + msg);
//	}
//	
//	private void throwError(String msg, Object element, Object leftResult, Object rightResult) throws Exception{
//		String left = "\n Left assertion ['" + Helper.assertionToString(((AssertionForm) element).getLeftAssert()) + "'] = ";
//		String right = "\n Right assertion ['" + Helper.assertionToString(((AssertionForm) element).getRightAssert()) + "'] = ";
//		if (leftResult instanceof DataObject && ((DataObject) leftResult).isEmpty()) {
//			left += "EMPTY!";
//		} else {
//			left += leftResult + " (Class: " + leftResult.getClass().getSimpleName() + ")";
//		}
//		if (rightResult instanceof DataObject && ((DataObject) rightResult).isEmpty()) {
//			right += "EMPTY!";
//		} else {
//			right += rightResult + " (Class: " + rightResult.getClass().getSimpleName() + ")";
//		}
//		throwError(msg + left + right, element);
//	}
	
	/**
	 * Returns the value corresponding to the passed key
	 * 
	 * @param key the name (and the key) of the variable to retrieve
	 * @return the corresponding value if the key is found, null otherwise
	 * @see Map#get(Object)
	 */
	//TODO da tenere?
	public static Object getVariable(String key) {
		return variables.get(key);
	}

}