/*
 * generated by me
 */
package org.xtext.example.xpt.generator;

import java.io.File;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.xtext.example.xpt.generator.dataobject.DataObject;
import org.xtext.example.xpt.xpt.Assertion;
import org.xtext.example.xpt.xpt.AssertionAnd;
import org.xtext.example.xpt.xpt.AssertionBraced;
import org.xtext.example.xpt.xpt.AssertionForm;
import org.xtext.example.xpt.xpt.AssertionNot;
import org.xtext.example.xpt.xpt.AssertionOr;
import org.xtext.example.xpt.xpt.AssertionQuantified;
import org.xtext.example.xpt.xpt.Assertions;
import org.xtext.example.xpt.xpt.Constant;
import org.xtext.example.xpt.xpt.Declaration;
import org.xtext.example.xpt.xpt.Function;
import org.xtext.example.xpt.xpt.Model;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

public class Main {

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	private static String queriesPath = "src/org/xtext/example/xpt/queries.xpt";
	private static String xmlFilePath = "src/org/xtext/example/xpt/book.xml";
	@SuppressWarnings("unused")
	private static String xmlFilePath2 = "src/org/xtext/example/xpt/book2.xml";

	private static Map<String, Object> variables = new HashMap<>();
	private static DataObject input = new DataObject();

	public static void main(String[] args) {
		Injector injector = new org.xtext.example.xpt.XptStandaloneSetupGenerated().createInjectorAndDoEMFRegistration();
		Main main = injector.getInstance(Main.class);

		File f = new File(queriesPath);
		String string = f.toURI().toString();

		main.runGenerator(string);
	}

	@SuppressWarnings("unused")
	private DataObject hashMapTest() {
		DataObject data = new DataObject();
		DataObject books = new DataObject();
		DataObject book1 = new DataObject();
		DataObject book2 = new DataObject();

		book1.put("title", "Snow Crash");
		book1.put("year", (double) 2000);
		book1.put("author", "Neal Stephenson");
		book1.put("publisher", "Spectra");
		book1.put("isbn", "0553380958");
		book1.put("price", (double) 15.0);
		books.put("book", book1);

		book2.put("title", "Burning Tower");
		book2.put("year", (double) 2005);
		book2.put("author", "Larry Niven");
		book2.put("author", "Jerry Pournelle");
		book2.put("publisher", "Pocket");
		book2.put("isbn", "0743416910");
		book2.put("price", (double) 5.99);
		books.put("book", book2);

		books.put("book", (double) 5);

		data.put("inventory", books);

		return data;
	}

	protected void runGenerator(String string) {
		// load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createURI(string), true);

		// validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			System.err.println("*** MALFORMED ASSERTIONS ***");
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return;
		}

		// get contents
		Model model = (Model) resource.getContents().get(0);
		EObjectContainmentEList<Declaration> declarations = (EObjectContainmentEList<Declaration>) model.getDeclarations();
		Assertions assertionSet = model.getAssertionSet();

		// get num of assertions
		int count = 0;
		TreeIterator<EObject> a = assertionSet.eAllContents();
		if (assertionSet instanceof AssertionForm) {
			count = count + 1;
		}
		while (a.hasNext()) {
			EObject next = a.next();
			if (next instanceof AssertionForm) {
				count = count + 1;
			}
		}

		// get input: via xml parsing or passed DataObject
		input = new DataObject(xmlFilePath);
		// input = hashMapTest();
		System.out.println("################## INPUT ###################\n" + input + "\n");

		if (count == 0) {
			System.out.println("No assertions. Execution halted.");
			return;
		}

		System.out.println("################## RULES ###################");
		System.out.println(declarations.size() + " variable declarated.");
		System.out.println(count + " assertions has been found.\n");

		// get variables declaration and sets the hashmap
		setVariable(declarations);

		// verify the assertions
		System.out.println("\n################ ASSERTIONS ################");
		System.out.println("Result: " + verifyAssertions(assertionSet));

	}

	/**
	 * Method for the evaluation of the assertions, considering the operation (NOT, AND, OR) and the corresponding priority (NOT>AND>OR)
	 * 
	 * @param assertions
	 *            the list of assertions to evaluate
	 * @return true if the assertions are respected, false otherwise
	 */
	private boolean verifyAssertions(Assertions assertions) {
		EList<EObject> a = assertions.eContents();
		if (assertions instanceof AssertionAnd) {
			return (verifyAssertions((Assertions) a.get(0)) & verifyAssertions((Assertions) a.get(1)));
		} else if (assertions instanceof AssertionOr) {
			return (verifyAssertions((Assertions) a.get(0)) | verifyAssertions((Assertions) a.get(1)));
		} else if (assertions instanceof AssertionNot) {
			return !verifyAssertions(((AssertionNot) assertions).getInnerFormula());
		} else if (assertions instanceof AssertionBraced) {
			return verifyAssertions(((AssertionBraced) assertions).getInnerFormula());
		} else if (assertions instanceof AssertionQuantified) {
			return false;
		} else if (assertions instanceof AssertionForm) {
			try {
				return verifyAssertionForm((AssertionForm) assertions);
			} catch (Exception e) {
				e.printStackTrace();
				System.exit(0);
			}
		}
		return false;
	}

	/**
	 * Check all the assertions
	 * 
	 * @param assertionSet
	 * @throws Exception
	 */
	private boolean verifyAssertionForm(AssertionForm af) throws Exception {
		Object laObj = doQueries(af.getLeftAssert());
		Object raObj = doQueries(af.getRightAssert());
		String operation = af.getOp(); // get Op for using it for the comparisons
		String condition = Helper.assertionFormToString(af);

		// check the objects class and evaluate the corresponding assertion
		if (laObj instanceof Double && raObj instanceof Double) {
			return numericAssertion((double) laObj, (double) raObj, operation, condition);
		} else if (laObj instanceof String && raObj instanceof String) {
			return stringAssertion((String) laObj, (String) raObj, operation, condition);
		} else if (laObj instanceof DataObject && raObj instanceof DataObject) {
			return dataobjectAssertion((DataObject) laObj, (DataObject) raObj, operation, condition);
		} else if (laObj instanceof Boolean && raObj instanceof Boolean) {
			return booleanAssertion((boolean) laObj, (boolean) raObj, operation, condition);
		} else if (laObj != null && raObj != null) {
			System.err.println("Assertion '" + condition + "' malformed: data types conflict.");
			throw new Exception();
		} else {
			System.err.println("Unable to evaluate assertion '" + condition + "', due to erroneous variables declaration.");
			throw new Exception();
		}
	}

	/**
	 * Method for the evaluation of numeric assertion
	 * 
	 * @param left
	 *            the result of the left assertion
	 * @param right
	 *            the result of the right assertion
	 * @param operation
	 *            a string containing the operation to evaluate
	 * @param condition
	 *            a string representation of the assertion
	 * @return true if the assertion is correct, false otherwise
	 */
	private boolean numericAssertion(double left, double right, String operation, String condition) {
		boolean result;
		switch (operation) {
		case ">":
			if (left > right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case ">=":
			if (left >= right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "<":
			if (left < right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "<=":
			if (left <= right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "=":
			if (left == right) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "!=":
			if (left != right) {
				result = true;
			} else {
				result = false;
			}
			break;
		default:
			result = false;
			break;
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Method for the evaluation of string assertion
	 * 
	 * @param left
	 *            the result of the left assertion
	 * @param right
	 *            the result of the right assertion
	 * @param operation
	 *            a string containing the operation to evaluate
	 * @param condition
	 *            a string representation of the assertion
	 * @return true if the assertion is correct, false otherwise
	 */
	private boolean stringAssertion(String left, String right, String operation, String condition) {
		boolean result;
		switch (operation) {
		case "=":
			if (left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "!=":
			if (!left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		default:
			result = false;
			break;
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Method for the evaluation of boolean assertion
	 * 
	 * @param left
	 *            the result of the left assertion
	 * @param right
	 *            the result of the right assertion
	 * @param operation
	 *            a string containing the operation to evaluate
	 * @param condition
	 *            a string representation of the assertion
	 * @return true if the assertion is correct, false otherwise
	 */
	private boolean booleanAssertion(boolean left, boolean right, String operation, String condition) {
		boolean result;
		switch (operation) {
		case "=":
			result = left == right;
			break;
		case "!=":
			result = left != right;
			break;
		default:
			result = false; // TODO eccezione
			break;
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Method for the evaluation of DataObject assertion
	 * 
	 * @param left
	 *            the result of the left assertion
	 * @param right
	 *            the result of the right assertion
	 * @param operation
	 *            a string containing the operation to evaluate
	 * @param condition
	 *            a string representation of the assertion
	 * @return true if the assertion is correct, false otherwise
	 */
	private boolean dataobjectAssertion(DataObject left, DataObject right, String operation, String condition) {
		boolean result;
		switch (operation) {
		case "=":
			if (left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		case "!=":
			if (!left.equals(right)) {
				result = true;
			} else {
				result = false;
			}
			break;
		default:
			result = false;
			break;
		}

		if (result) {
			System.out.println("Assertion '" + condition + "' is verified.");
		} else {
			System.out.println("Assertion '" + condition + "' is wrong.");
		}

		return result;
	}

	/**
	 * Print the result of the evaluation of queries
	 * 
	 * @throws Exception
	 */
	private Object doQueries(Assertion assertion) throws Exception {

		if (assertion instanceof AssertionQuantified) {
			return doAssertionQuantified(assertion);
		}

		Object result = new Object();
		// if the assertion is a constant it's not going to be an xpath query
		if (assertion.getConstant() != null) {
			return ((assertion.getConstant().getString() == null) ? assertion.getConstant().getNumber() : assertion.getConstant().getString());
		}
		// look if there's a placeholder, if any substitute it with its values (note: the placeholder is always on the first step!)
		if (assertion.getQuery() != null) {
			String placeholder = assertion.getQuery().getSteps().get(0).getPlaceholder();

			if (placeholder != null) {
				if (!variables.containsKey(placeholder)) {
					return null; // TODO da valutare come trattare (dichiarazioni sbagliate -> variabile assente)
				}
				Object value = variables.get(placeholder);
				try {
					if (assertion.getQuery().getSteps().size() > 1) { // if there query goes deeper
						result = ((DataObject) value).evaluate(assertion.getQuery());
						if (((DataObject) result).isSingleValue()) {
							result = ((DataObject) result).getFirst();
						}
					} else if (value instanceof String || value instanceof Double || value instanceof Boolean) {
						result = value;
					} else {
						if (((DataObject) value).isSingleValue()) {
							result = ((DataObject) value).getFirst();
						} else {
							result = value;
						}
					}
				} catch (ClassCastException e) {
					result = value;
				}
			} else {
				result = input.evaluate(assertion.getQuery());
			}
		} else {
			result = assertion.isBoolean();
		}

		// *** FUNCTIONS ***
		if (assertion.getFunction() != null) {
			if (result instanceof DataObject) {
				// TODO
			} else if (result instanceof String) {
				result = applyStringFunctions(result, assertion.getFunction());
			} else if (result instanceof Double) {
				result = applyDoubleFunctions(result, assertion.getFunction());
			}
		}
		return result;
	}

	private Object doAssertionQuantified(Assertion assertion) throws Exception {
		AssertionQuantified aq = (AssertionQuantified) assertion;

		if (!(variables.get(aq.getVar()) instanceof DataObject)) {
			throw new Exception(); // it's a single value (String, Double or Boolean), so we could not iterate over it
		}

		DataObject set = (DataObject) variables.get(aq.getVar());
		String alias = aq.getAlias();
		boolean result;

		if (variables.containsKey(alias)) { // variable name already used
			throw new Exception();
		}

		Iterator<Object> iter = set.values().iterator();

		switch (aq.getQuantifier()) {
		case "forall":
			while (iter.hasNext()) {
				variables.put(alias, iter.next());
				result = verifyAssertions(aq.getConditions());
				if (!result) {
					return false;
				}
			}
			return true;
		case "exists":
			result = false;
			while (iter.hasNext()) {
				variables.put(alias, iter.next());
				result = result | verifyAssertions(aq.getConditions());
			}
			return true;
		case "numOf":
			double count = 0;
			while(iter.hasNext()) {
				variables.put(alias, iter.next());
				if(verifyAssertions(aq.getConditions())) {
					count = count + 1;
				}
			}
			return count;
		default:
			return null; //TODO
		}
	}

	private Object applyStringFunctions(Object object, Function function) {
		EList<Constant> params = null;
		if (function.getParams() != null) {
			params = function.getParams().getValue();
		}
		switch (function.getName()) {
		case "uppercase":
			if (params == null) {
				return ((String) object).toUpperCase();
			} else {
				return null;
			}
		case "length":
			if (params == null) {
				return (double) ((String) object).length();
			} else {
				return null;
			}
		case "startsWith":
			if (params != null && params.size() == 1) {
				String prefix = (params.get(0).getString() != null) ? params.get(0).getString() : String.valueOf(params.get(0).getNumber());
				return ((String) object).startsWith(prefix);
			} else {
				return null;
			}
		case "endsWith":
			if (params != null && params.size() == 1) {
				String suffix = (params.get(0).getString() != null) ? params.get(0).getString() : String.valueOf(params.get(0).getNumber());
				return ((String) object).endsWith(suffix);
			} else {
				return null;
			}
		case "substring":
			if (params != null && params.size() == 2) {
				int beginIndex = (Math.rint(params.get(0).getNumber()) == params.get(0).getNumber()) ? (int) params.get(0).getNumber() : null;
				int endIndex = (Math.rint(params.get(1).getNumber()) == params.get(1).getNumber()) ? (int) params.get(1).getNumber() : null;
				return ((String) object).substring(beginIndex, endIndex);
			} else {
				return null;
			}
		case "replace":
			if (params != null && params.size() == 2) {
				return ((String) object).replace(params.get(0).getString(), params.get(1).getString());
			} else {
				return null;
			}
		default:
			return null;
		}
	}

	private Object applyDoubleFunctions(Object object, Function function) {
		EList<Constant> params = null;
		if (function.getParams() != null) {
			params = function.getParams().getValue();
		}
		switch (function.getName()) {
		case "abs":
			if (params == null) {
				return Math.abs((double) object);
			} else {
				return null;
			}
		case "length":
			if (params == null) {
				return (double) String.valueOf((double) object).length();
			} else {
				return null;
			}
		default:
			return null;
		}
	}

	/**
	 * Set variables according to the declarations
	 */
	private void setVariable(EObjectContainmentEList<Declaration> declarations) {
		System.out.println("############### DECLARATIONS ###############");
		for (Declaration d : declarations) {
			if (d.getAssert().getConstant() != null) {
				if (d.getAssert().getConstant().getString() != null) {
					variables.put(d.getVar(), d.getAssert().getConstant().getString());
				} else {
					variables.put(d.getVar(), d.getAssert().getConstant().getNumber());
				}
			} else if (d.getAssert().getValues() != null) {
				variables.put(d.getVar(), new DataObject(d.getVar(), d.getAssert().getValues()));
			} else if (d.getAssert().getQuery() != null) {
				DataObject result = input.evaluate(d.getAssert().getQuery());
				// TODO come trattare il fatto di avere un risultato?
				// if the assertion is wrong (with respect to the input variable) or empty the program is halted
				if (result == null) {
					System.err.println("Unable to evaluate '" + d.getVar() + " = " + Helper.assertionToString(d.getAssert()) + "'. Please check it.");
					System.exit(0);
				} else {
					variables.put(d.getVar(), result);
				}
			} else if(d.getAssert() instanceof AssertionQuantified) {
				try {
					Object result = doAssertionQuantified(d.getAssert());
					variables.put(d.getVar(), result);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				variables.put(d.getVar(), d.getAssert().isBoolean());
			}
			System.out.println(d.getVar() + " = " + Helper.assertionToString(d.getAssert()));
		}
		return;
	}

}