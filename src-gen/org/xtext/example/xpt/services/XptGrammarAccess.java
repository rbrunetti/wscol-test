/*
* generated by Xtext
*/
package org.xtext.example.xpt.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class XptGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeclarationsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeclarationsDeclarationParserRuleCall_0_0 = (RuleCall)cDeclarationsAssignment_0.eContents().get(0);
		private final Assignment cAssertionSetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAssertionSetAssertionOrParserRuleCall_1_0 = (RuleCall)cAssertionSetAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Model:
		//	declarations+=Declaration* assertionSet=AssertionOr ";";
		public ParserRule getRule() { return rule; }

		//declarations+=Declaration* assertionSet=AssertionOr ";"
		public Group getGroup() { return cGroup; }

		//declarations+=Declaration*
		public Assignment getDeclarationsAssignment_0() { return cDeclarationsAssignment_0; }

		//Declaration
		public RuleCall getDeclarationsDeclarationParserRuleCall_0_0() { return cDeclarationsDeclarationParserRuleCall_0_0; }

		//assertionSet=AssertionOr
		public Assignment getAssertionSetAssignment_1() { return cAssertionSetAssignment_1; }

		//AssertionOr
		public RuleCall getAssertionSetAssertionOrParserRuleCall_1_0() { return cAssertionSetAssertionOrParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarVariableParserRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAssertAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cAssertAlternatives_3_0 = (Alternatives)cAssertAssignment_3.eContents().get(0);
		private final RuleCall cAssertAssertionParserRuleCall_3_0_0 = (RuleCall)cAssertAlternatives_3_0.eContents().get(0);
		private final RuleCall cAssertAssertionQuantifiedBooleanParserRuleCall_3_0_1 = (RuleCall)cAssertAlternatives_3_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// Assign to the variable a value (a String, Double, Boolean or SDO)
		//Declaration:
		//	"let" var=Variable "=" assert=(Assertion | AssertionQuantifiedBoolean) ";";
		public ParserRule getRule() { return rule; }

		//"let" var=Variable "=" assert=(Assertion | AssertionQuantifiedBoolean) ";"
		public Group getGroup() { return cGroup; }

		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }

		//var=Variable
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_1_0() { return cVarVariableParserRuleCall_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//assert=(Assertion | AssertionQuantifiedBoolean)
		public Assignment getAssertAssignment_3() { return cAssertAssignment_3; }

		//Assertion | AssertionQuantifiedBoolean
		public Alternatives getAssertAlternatives_3_0() { return cAssertAlternatives_3_0; }

		//Assertion
		public RuleCall getAssertAssertionParserRuleCall_3_0_0() { return cAssertAssertionParserRuleCall_3_0_0; }

		//AssertionQuantifiedBoolean
		public RuleCall getAssertAssertionQuantifiedBooleanParserRuleCall_3_0_1() { return cAssertAssertionQuantifiedBooleanParserRuleCall_3_0_1; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class AssertionOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAssertionAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssertionOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAssertionAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// Assertion results in logical operation OR
		//AssertionOr returns Assertions:
		//	AssertionAnd ({AssertionOr.left=current} "||" right=AssertionAnd)*;
		public ParserRule getRule() { return rule; }

		//AssertionAnd ({AssertionOr.left=current} "||" right=AssertionAnd)*
		public Group getGroup() { return cGroup; }

		//AssertionAnd
		public RuleCall getAssertionAndParserRuleCall_0() { return cAssertionAndParserRuleCall_0; }

		//({AssertionOr.left=current} "||" right=AssertionAnd)*
		public Group getGroup_1() { return cGroup_1; }

		//{AssertionOr.left=current}
		public Action getAssertionOrLeftAction_1_0() { return cAssertionOrLeftAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//right=AssertionAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AssertionAnd
		public RuleCall getRightAssertionAndParserRuleCall_1_2_0() { return cRightAssertionAndParserRuleCall_1_2_0; }
	}

	public class AssertionAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAssertionHPParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssertionAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAssertionHPParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// Assertion results in logical operation AND
		//AssertionAnd returns Assertions:
		//	AssertionHP ({AssertionAnd.left=current} "&&" right=AssertionHP)*;
		public ParserRule getRule() { return rule; }

		//AssertionHP ({AssertionAnd.left=current} "&&" right=AssertionHP)*
		public Group getGroup() { return cGroup; }

		//AssertionHP
		public RuleCall getAssertionHPParserRuleCall_0() { return cAssertionHPParserRuleCall_0; }

		//({AssertionAnd.left=current} "&&" right=AssertionHP)*
		public Group getGroup_1() { return cGroup_1; }

		//{AssertionAnd.left=current}
		public Action getAssertionAndLeftAction_1_0() { return cAssertionAndLeftAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//right=AssertionHP
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AssertionHP
		public RuleCall getRightAssertionHPParserRuleCall_1_2_0() { return cRightAssertionHPParserRuleCall_1_2_0; }
	}

	public class AssertionHPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionHP");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssertionNotParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssertionBracedParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAssertionFormParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// Assertion results in logical operation with highest priority (NOT and parentheses)
		//AssertionHP returns Assertions:
		//	AssertionNot | AssertionBraced | AssertionForm;
		public ParserRule getRule() { return rule; }

		//AssertionNot | AssertionBraced | AssertionForm
		public Alternatives getAlternatives() { return cAlternatives; }

		//AssertionNot
		public RuleCall getAssertionNotParserRuleCall_0() { return cAssertionNotParserRuleCall_0; }

		//AssertionBraced
		public RuleCall getAssertionBracedParserRuleCall_1() { return cAssertionBracedParserRuleCall_1; }

		//AssertionForm
		public RuleCall getAssertionFormParserRuleCall_2() { return cAssertionFormParserRuleCall_2; }
	}

	public class AssertionBracedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionBraced");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInnerFormulaAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInnerFormulaAssertionOrParserRuleCall_1_0 = (RuleCall)cInnerFormulaAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Assertion with parentheses
		//AssertionBraced:
		//	"(" innerFormula=AssertionOr ")";
		public ParserRule getRule() { return rule; }

		//"(" innerFormula=AssertionOr ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//innerFormula=AssertionOr
		public Assignment getInnerFormulaAssignment_1() { return cInnerFormulaAssignment_1; }

		//AssertionOr
		public RuleCall getInnerFormulaAssertionOrParserRuleCall_1_0() { return cInnerFormulaAssertionOrParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class AssertionNotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionNot");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInnerFormulaAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInnerFormulaAssertionOrParserRuleCall_2_0 = (RuleCall)cInnerFormulaAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Assertion with logical operator NOT
		//AssertionNot:
		//	"!" "(" innerFormula=AssertionOr ")";
		public ParserRule getRule() { return rule; }

		//"!" "(" innerFormula=AssertionOr ")"
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//innerFormula=AssertionOr
		public Assignment getInnerFormulaAssignment_2() { return cInnerFormulaAssignment_2; }

		//AssertionOr
		public RuleCall getInnerFormulaAssertionOrParserRuleCall_2_0() { return cInnerFormulaAssertionOrParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class AssertionFormElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionForm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssertionStdCmpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssertionQuantifiedBooleanParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAssertionBooleanParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// Kinds of Assertion: with comparison and without (2nd and 3rd case are for boolean comparison and their result is implicitly 'true')
		//AssertionForm:
		//	AssertionStdCmp | AssertionQuantifiedBoolean | AssertionBoolean;
		public ParserRule getRule() { return rule; }

		//=> AssertionStdCmp | AssertionQuantifiedBoolean | AssertionBoolean
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> AssertionStdCmp
		public RuleCall getAssertionStdCmpParserRuleCall_0() { return cAssertionStdCmpParserRuleCall_0; }

		//AssertionQuantifiedBoolean
		public RuleCall getAssertionQuantifiedBooleanParserRuleCall_1() { return cAssertionQuantifiedBooleanParserRuleCall_1; }

		//AssertionBoolean
		public RuleCall getAssertionBooleanParserRuleCall_2() { return cAssertionBooleanParserRuleCall_2; }
	}

	public class AssertionStdCmpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionStdCmp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssertAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftAssertAssertionParserRuleCall_0_0 = (RuleCall)cLeftAssertAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpRopParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssertAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightAssertAssertionParserRuleCall_2_0 = (RuleCall)cRightAssertAssignment_2.eContents().get(0);
		
		//// Assertions making a standard comparison between values
		//AssertionStdCmp:
		//	leftAssert=Assertion op=Rop rightAssert=Assertion;
		public ParserRule getRule() { return rule; }

		//leftAssert=Assertion op=Rop rightAssert=Assertion
		public Group getGroup() { return cGroup; }

		//leftAssert=Assertion
		public Assignment getLeftAssertAssignment_0() { return cLeftAssertAssignment_0; }

		//Assertion
		public RuleCall getLeftAssertAssertionParserRuleCall_0_0() { return cLeftAssertAssertionParserRuleCall_0_0; }

		//op=Rop
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//Rop
		public RuleCall getOpRopParserRuleCall_1_0() { return cOpRopParserRuleCall_1_0; }

		//rightAssert=Assertion
		public Assignment getRightAssertAssignment_2() { return cRightAssertAssignment_2; }

		//Assertion
		public RuleCall getRightAssertAssertionParserRuleCall_2_0() { return cRightAssertAssertionParserRuleCall_2_0; }
	}

	public class AssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assertion");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cStepsAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cStepsStepParserRuleCall_0_0_0 = (RuleCall)cStepsAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cFunctionsAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_0_1_1_0 = (RuleCall)cFunctionsAssignment_0_1_1.eContents().get(0);
		private final RuleCall cAssertionQuantifiedNumericParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cValuesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValuesValuesParserRuleCall_2_1_0 = (RuleCall)cValuesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cConstantAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cConstantConstantParserRuleCall_3_0 = (RuleCall)cConstantAssignment_3.eContents().get(0);
		
		//// Assertion
		//Assertion:
		//	steps+=Step+ ("." functions+=Function)* | AssertionQuantifiedNumeric | "[" values=Values "]" | constant=Constant;
		public ParserRule getRule() { return rule; }

		//steps+=Step+ ("." functions+=Function)* | AssertionQuantifiedNumeric | "[" values=Values "]" | constant=Constant
		public Alternatives getAlternatives() { return cAlternatives; }

		//steps+=Step+ ("." functions+=Function)*
		public Group getGroup_0() { return cGroup_0; }

		//steps+=Step+
		public Assignment getStepsAssignment_0_0() { return cStepsAssignment_0_0; }

		//Step
		public RuleCall getStepsStepParserRuleCall_0_0_0() { return cStepsStepParserRuleCall_0_0_0; }

		//("." functions+=Function)*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"."
		public Keyword getFullStopKeyword_0_1_0() { return cFullStopKeyword_0_1_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_0_1_1() { return cFunctionsAssignment_0_1_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_0_1_1_0() { return cFunctionsFunctionParserRuleCall_0_1_1_0; }

		//AssertionQuantifiedNumeric
		public RuleCall getAssertionQuantifiedNumericParserRuleCall_1() { return cAssertionQuantifiedNumericParserRuleCall_1; }

		//"[" values=Values "]"
		public Group getGroup_2() { return cGroup_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//values=Values
		public Assignment getValuesAssignment_2_1() { return cValuesAssignment_2_1; }

		//Values
		public RuleCall getValuesValuesParserRuleCall_2_1_0() { return cValuesValuesParserRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }

		//constant=Constant
		public Assignment getConstantAssignment_3() { return cConstantAssignment_3; }

		//Constant
		public RuleCall getConstantConstantParserRuleCall_3_0() { return cConstantConstantParserRuleCall_3_0; }
	}

	public class AssertionBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionBoolean");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStepsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStepsStepParserRuleCall_0_0 = (RuleCall)cStepsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cFunctionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_1_1_0 = (RuleCall)cFunctionsAssignment_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFunctionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFunctionsFunctionBooleanParserRuleCall_3_0 = (RuleCall)cFunctionsAssignment_3.eContents().get(0);
		
		//// Assertion with boolean result
		//AssertionBoolean returns Assertion:
		//	steps+=Step+ ("." functions+=Function)* "." functions+=FunctionBoolean;
		public ParserRule getRule() { return rule; }

		//steps+=Step+ ("." functions+=Function)* "." functions+=FunctionBoolean
		public Group getGroup() { return cGroup; }

		//steps+=Step+
		public Assignment getStepsAssignment_0() { return cStepsAssignment_0; }

		//Step
		public RuleCall getStepsStepParserRuleCall_0_0() { return cStepsStepParserRuleCall_0_0; }

		//("." functions+=Function)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_1_1() { return cFunctionsAssignment_1_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_1_1_0() { return cFunctionsFunctionParserRuleCall_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }

		//functions+=FunctionBoolean
		public Assignment getFunctionsAssignment_3() { return cFunctionsAssignment_3; }

		//FunctionBoolean
		public RuleCall getFunctionsFunctionBooleanParserRuleCall_3_0() { return cFunctionsFunctionBooleanParserRuleCall_3_0; }
	}

	public class AssertionQuantifiedBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionQuantifiedBoolean");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQuantifierBoolQuantifierParserRuleCall_0_0 = (RuleCall)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAliasAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAliasVariableParserRuleCall_2_0 = (RuleCall)cAliasAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVarAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarVariableParserRuleCall_4_0 = (RuleCall)cVarAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cConditionsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cConditionsAssertionOrParserRuleCall_6_0 = (RuleCall)cConditionsAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// Assertion with quantifiers for boolean results
		//AssertionQuantifiedBoolean returns AssertionQuantified:
		//	quantifier=BoolQuantifier "(" alias=Variable "in" var=Variable "," conditions=AssertionOr ")";
		public ParserRule getRule() { return rule; }

		//quantifier=BoolQuantifier "(" alias=Variable "in" var=Variable "," conditions=AssertionOr ")"
		public Group getGroup() { return cGroup; }

		//quantifier=BoolQuantifier
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }

		//BoolQuantifier
		public RuleCall getQuantifierBoolQuantifierParserRuleCall_0_0() { return cQuantifierBoolQuantifierParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//alias=Variable
		public Assignment getAliasAssignment_2() { return cAliasAssignment_2; }

		//Variable
		public RuleCall getAliasVariableParserRuleCall_2_0() { return cAliasVariableParserRuleCall_2_0; }

		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }

		//var=Variable
		public Assignment getVarAssignment_4() { return cVarAssignment_4; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_4_0() { return cVarVariableParserRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//conditions=AssertionOr
		public Assignment getConditionsAssignment_6() { return cConditionsAssignment_6; }

		//AssertionOr
		public RuleCall getConditionsAssertionOrParserRuleCall_6_0() { return cConditionsAssertionOrParserRuleCall_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}

	public class AssertionQuantifiedNumericElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionQuantifiedNumeric");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQuantifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQuantifierNumbQuantifierParserRuleCall_0_0 = (RuleCall)cQuantifierAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAliasAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAliasVariableParserRuleCall_2_0 = (RuleCall)cAliasAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVarAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarVariableParserRuleCall_4_0 = (RuleCall)cVarAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cConditionsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cConditionsAssertionOrParserRuleCall_6_0 = (RuleCall)cConditionsAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// Assertion with quantifiers for numeric results
		//AssertionQuantifiedNumeric returns AssertionQuantified:
		//	quantifier=NumbQuantifier "(" alias=Variable "in" var=Variable "," conditions=AssertionOr ")";
		public ParserRule getRule() { return rule; }

		//quantifier=NumbQuantifier "(" alias=Variable "in" var=Variable "," conditions=AssertionOr ")"
		public Group getGroup() { return cGroup; }

		//quantifier=NumbQuantifier
		public Assignment getQuantifierAssignment_0() { return cQuantifierAssignment_0; }

		//NumbQuantifier
		public RuleCall getQuantifierNumbQuantifierParserRuleCall_0_0() { return cQuantifierNumbQuantifierParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//alias=Variable
		public Assignment getAliasAssignment_2() { return cAliasAssignment_2; }

		//Variable
		public RuleCall getAliasVariableParserRuleCall_2_0() { return cAliasVariableParserRuleCall_2_0; }

		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }

		//var=Variable
		public Assignment getVarAssignment_4() { return cVarAssignment_4; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_4_0() { return cVarVariableParserRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//conditions=AssertionOr
		public Assignment getConditionsAssignment_6() { return cConditionsAssignment_6; }

		//AssertionOr
		public RuleCall getConditionsAssertionOrParserRuleCall_6_0() { return cConditionsAssertionOrParserRuleCall_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}

	public class StepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Step");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cAttributeAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cAttributeAttributeParserRuleCall_0_2_1_0 = (RuleCall)cAttributeAssignment_0_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Assignment cPlaceholderAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cPlaceholderVariableParserRuleCall_1_0 = (RuleCall)cPlaceholderAssignment_1.eContents().get(0);
		
		//// Steps describing the navigation path through an SDO
		//Step:
		//	"/" name=ID ("[" attribute=Attribute "]")? | placeholder=Variable;
		public ParserRule getRule() { return rule; }

		//"/" name=ID ("[" attribute=Attribute "]")? | placeholder=Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//"/" name=ID ("[" attribute=Attribute "]")?
		public Group getGroup_0() { return cGroup_0; }

		//"/"
		public Keyword getSolidusKeyword_0_0() { return cSolidusKeyword_0_0; }

		//name=ID
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_0() { return cNameIDTerminalRuleCall_0_1_0; }

		//("[" attribute=Attribute "]")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_2_0() { return cLeftSquareBracketKeyword_0_2_0; }

		//attribute=Attribute
		public Assignment getAttributeAssignment_0_2_1() { return cAttributeAssignment_0_2_1; }

		//Attribute
		public RuleCall getAttributeAttributeParserRuleCall_0_2_1_0() { return cAttributeAttributeParserRuleCall_0_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_2_2() { return cRightSquareBracketKeyword_0_2_2; }

		//placeholder=Variable
		public Assignment getPlaceholderAssignment_1() { return cPlaceholderAssignment_1; }

		//Variable
		public RuleCall getPlaceholderVariableParserRuleCall_1_0() { return cPlaceholderVariableParserRuleCall_1_0; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cPropertyAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cPropertyIDTerminalRuleCall_0_0_0 = (RuleCall)cPropertyAssignment_0_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final Group cGroup_0_1_0 = (Group)cAlternatives_0_1.eContents().get(0);
		private final Assignment cOpAssignment_0_1_0_0 = (Assignment)cGroup_0_1_0.eContents().get(0);
		private final RuleCall cOpRopParserRuleCall_0_1_0_0_0 = (RuleCall)cOpAssignment_0_1_0_0.eContents().get(0);
		private final Assignment cNumberValueAssignment_0_1_0_1 = (Assignment)cGroup_0_1_0.eContents().get(1);
		private final RuleCall cNumberValueNUMBERTerminalRuleCall_0_1_0_1_0 = (RuleCall)cNumberValueAssignment_0_1_0_1.eContents().get(0);
		private final Group cGroup_0_1_1 = (Group)cAlternatives_0_1.eContents().get(1);
		private final Assignment cOpAssignment_0_1_1_0 = (Assignment)cGroup_0_1_1.eContents().get(0);
		private final RuleCall cOpStringRopParserRuleCall_0_1_1_0_0 = (RuleCall)cOpAssignment_0_1_1_0.eContents().get(0);
		private final Assignment cStrValueAssignment_0_1_1_1 = (Assignment)cGroup_0_1_1.eContents().get(1);
		private final RuleCall cStrValueSTRINGTerminalRuleCall_0_1_1_1_0 = (RuleCall)cStrValueAssignment_0_1_1_1.eContents().get(0);
		private final Group cGroup_0_1_2 = (Group)cAlternatives_0_1.eContents().get(2);
		private final Assignment cOpAssignment_0_1_2_0 = (Assignment)cGroup_0_1_2.eContents().get(0);
		private final RuleCall cOpRopParserRuleCall_0_1_2_0_0 = (RuleCall)cOpAssignment_0_1_2_0.eContents().get(0);
		private final Assignment cVarValueAssignment_0_1_2_1 = (Assignment)cGroup_0_1_2.eContents().get(1);
		private final RuleCall cVarValueVariableParserRuleCall_0_1_2_1_0 = (RuleCall)cVarValueAssignment_0_1_2_1.eContents().get(0);
		private final Assignment cNumberAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNumberNUMBERTerminalRuleCall_1_0 = (RuleCall)cNumberAssignment_1.eContents().get(0);
		private final Assignment cVarAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cVarVariableParserRuleCall_2_0 = (RuleCall)cVarAssignment_2.eContents().get(0);
		
		//// Attribute for SDO navigation: according to the operation checks the searched value, if possible
		//Attribute:
		//	property=ID (op=Rop numberValue=NUMBER | op=StringRop strValue=STRING | op=Rop varValue=Variable) | number=NUMBER |
		//	var=Variable;
		public ParserRule getRule() { return rule; }

		//property=ID (op=Rop numberValue=NUMBER | op=StringRop strValue=STRING | op=Rop varValue=Variable) | number=NUMBER |
		//var=Variable
		public Alternatives getAlternatives() { return cAlternatives; }

		//property=ID (op=Rop numberValue=NUMBER | op=StringRop strValue=STRING | op=Rop varValue=Variable)
		public Group getGroup_0() { return cGroup_0; }

		//property=ID
		public Assignment getPropertyAssignment_0_0() { return cPropertyAssignment_0_0; }

		//ID
		public RuleCall getPropertyIDTerminalRuleCall_0_0_0() { return cPropertyIDTerminalRuleCall_0_0_0; }

		//op=Rop numberValue=NUMBER | op=StringRop strValue=STRING | op=Rop varValue=Variable
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//op=Rop numberValue=NUMBER
		public Group getGroup_0_1_0() { return cGroup_0_1_0; }

		//op=Rop
		public Assignment getOpAssignment_0_1_0_0() { return cOpAssignment_0_1_0_0; }

		//Rop
		public RuleCall getOpRopParserRuleCall_0_1_0_0_0() { return cOpRopParserRuleCall_0_1_0_0_0; }

		//numberValue=NUMBER
		public Assignment getNumberValueAssignment_0_1_0_1() { return cNumberValueAssignment_0_1_0_1; }

		//NUMBER
		public RuleCall getNumberValueNUMBERTerminalRuleCall_0_1_0_1_0() { return cNumberValueNUMBERTerminalRuleCall_0_1_0_1_0; }

		//op=StringRop strValue=STRING
		public Group getGroup_0_1_1() { return cGroup_0_1_1; }

		//op=StringRop
		public Assignment getOpAssignment_0_1_1_0() { return cOpAssignment_0_1_1_0; }

		//StringRop
		public RuleCall getOpStringRopParserRuleCall_0_1_1_0_0() { return cOpStringRopParserRuleCall_0_1_1_0_0; }

		//strValue=STRING
		public Assignment getStrValueAssignment_0_1_1_1() { return cStrValueAssignment_0_1_1_1; }

		//STRING
		public RuleCall getStrValueSTRINGTerminalRuleCall_0_1_1_1_0() { return cStrValueSTRINGTerminalRuleCall_0_1_1_1_0; }

		//op=Rop varValue=Variable
		public Group getGroup_0_1_2() { return cGroup_0_1_2; }

		//op=Rop
		public Assignment getOpAssignment_0_1_2_0() { return cOpAssignment_0_1_2_0; }

		//Rop
		public RuleCall getOpRopParserRuleCall_0_1_2_0_0() { return cOpRopParserRuleCall_0_1_2_0_0; }

		//varValue=Variable
		public Assignment getVarValueAssignment_0_1_2_1() { return cVarValueAssignment_0_1_2_1; }

		//Variable
		public RuleCall getVarValueVariableParserRuleCall_0_1_2_1_0() { return cVarValueVariableParserRuleCall_0_1_2_1_0; }

		//number=NUMBER
		public Assignment getNumberAssignment_1() { return cNumberAssignment_1; }

		//NUMBER
		public RuleCall getNumberNUMBERTerminalRuleCall_1_0() { return cNumberNUMBERTerminalRuleCall_1_0; }

		//var=Variable
		public Assignment getVarAssignment_2() { return cVarAssignment_2; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_2_0() { return cVarVariableParserRuleCall_2_0; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamsValuesParserRuleCall_2_0 = (RuleCall)cParamsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Function
		//Function:
		//	name=ID "(" params=Values? ")";
		public ParserRule getRule() { return rule; }

		//name=ID "(" params=Values? ")"
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//params=Values?
		public Assignment getParamsAssignment_2() { return cParamsAssignment_2; }

		//Values
		public RuleCall getParamsValuesParserRuleCall_2_0() { return cParamsValuesParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FunctionBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionBoolean");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final Keyword cNameContainsKeyword_0_0_0 = (Keyword)cNameAlternatives_0_0.eContents().get(0);
		private final Keyword cNameStartsWithKeyword_0_0_1 = (Keyword)cNameAlternatives_0_0.eContents().get(1);
		private final Keyword cNameEndsWithKeyword_0_0_2 = (Keyword)cNameAlternatives_0_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamsValuesParserRuleCall_2_0 = (RuleCall)cParamsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Function that gives boolean result
		//FunctionBoolean returns Function:
		//	name=("contains" | "startsWith" | "endsWith") "(" params=Values? ")";
		public ParserRule getRule() { return rule; }

		//name=("contains" | "startsWith" | "endsWith") "(" params=Values? ")"
		public Group getGroup() { return cGroup; }

		//name=("contains" | "startsWith" | "endsWith")
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"contains" | "startsWith" | "endsWith"
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//"contains"
		public Keyword getNameContainsKeyword_0_0_0() { return cNameContainsKeyword_0_0_0; }

		//"startsWith"
		public Keyword getNameStartsWithKeyword_0_0_1() { return cNameStartsWithKeyword_0_0_1; }

		//"endsWith"
		public Keyword getNameEndsWithKeyword_0_0_2() { return cNameEndsWithKeyword_0_0_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//params=Values?
		public Assignment getParamsAssignment_2() { return cParamsAssignment_2; }

		//Values
		public RuleCall getParamsValuesParserRuleCall_2_0() { return cParamsValuesParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ValuesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Values");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValueValueParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueValueParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//// List of values
		//Values:
		//	value+=Value ("," value+=Value)*;
		public ParserRule getRule() { return rule; }

		//value+=Value ("," value+=Value)*
		public Group getGroup() { return cGroup; }

		//value+=Value
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }

		//Value
		public RuleCall getValueValueParserRuleCall_0_0() { return cValueValueParserRuleCall_0_0; }

		//("," value+=Value)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//value+=Value
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//Value
		public RuleCall getValueValueParserRuleCall_1_1_0() { return cValueValueParserRuleCall_1_1_0; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cStepsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStepsStepParserRuleCall_1_0_0 = (RuleCall)cStepsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cFullStopKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cFunctionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_1_1_1_0 = (RuleCall)cFunctionsAssignment_1_1_1.eContents().get(0);
		
		//// Value could be a constant (alphanumeric or numeric) or obtained by an SDO's property
		//Value:
		//	Constant | steps+=Step+ ("." functions+=Function)*;
		public ParserRule getRule() { return rule; }

		//Constant | steps+=Step+ ("." functions+=Function)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//Constant
		public RuleCall getConstantParserRuleCall_0() { return cConstantParserRuleCall_0; }

		//steps+=Step+ ("." functions+=Function)*
		public Group getGroup_1() { return cGroup_1; }

		//steps+=Step+
		public Assignment getStepsAssignment_1_0() { return cStepsAssignment_1_0; }

		//Step
		public RuleCall getStepsStepParserRuleCall_1_0_0() { return cStepsStepParserRuleCall_1_0_0; }

		//("." functions+=Function)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"."
		public Keyword getFullStopKeyword_1_1_0() { return cFullStopKeyword_1_1_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_1_1_1() { return cFunctionsAssignment_1_1_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_1_1_1_0() { return cFunctionsFunctionParserRuleCall_1_1_1_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumberNUMBERTerminalRuleCall_0_0 = (RuleCall)cNumberAssignment_0.eContents().get(0);
		private final Assignment cStringAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStringSTRINGTerminalRuleCall_1_0 = (RuleCall)cStringAssignment_1.eContents().get(0);
		
		//Constant:
		//	number=NUMBER | string=STRING;
		public ParserRule getRule() { return rule; }

		//number=NUMBER | string=STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//number=NUMBER
		public Assignment getNumberAssignment_0() { return cNumberAssignment_0; }

		//NUMBER
		public RuleCall getNumberNUMBERTerminalRuleCall_0_0() { return cNumberNUMBERTerminalRuleCall_0_0; }

		//string=STRING
		public Assignment getStringAssignment_1() { return cStringAssignment_1; }

		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_1_0() { return cStringSTRINGTerminalRuleCall_1_0; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cNumbQuantifierParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//// Variable (NumbQuantifier is added for give the possibility to use 'max', 'min', etc. as variables name)
		//Variable:
		//	"$" (ID | NumbQuantifier);
		public ParserRule getRule() { return rule; }

		//"$" (ID | NumbQuantifier)
		public Group getGroup() { return cGroup; }

		//"$"
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }

		//ID | NumbQuantifier
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_0() { return cIDTerminalRuleCall_1_0; }

		//NumbQuantifier
		public RuleCall getNumbQuantifierParserRuleCall_1_1() { return cNumbQuantifierParserRuleCall_1_1; }
	}

	public class BoolQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolQuantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cForallKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BoolQuantifier:
		//	"forall" | "exists";
		public ParserRule getRule() { return rule; }

		//"forall" | "exists"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"forall"
		public Keyword getForallKeyword_0() { return cForallKeyword_0; }

		//"exists"
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }
	}

	public class NumbQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumbQuantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNumOfKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSumKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAvgKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cMinKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cMaxKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cProductKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//NumbQuantifier:
		//	"numOf" | "sum" | "avg" | "min" | "max" | "product";
		public ParserRule getRule() { return rule; }

		//"numOf" | "sum" | "avg" | "min" | "max" | "product"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"numOf"
		public Keyword getNumOfKeyword_0() { return cNumOfKeyword_0; }

		//"sum"
		public Keyword getSumKeyword_1() { return cSumKeyword_1; }

		//"avg"
		public Keyword getAvgKeyword_2() { return cAvgKeyword_2; }

		//"min"
		public Keyword getMinKeyword_3() { return cMinKeyword_3; }

		//"max"
		public Keyword getMaxKeyword_4() { return cMaxKeyword_4; }

		//"product"
		public Keyword getProductKeyword_5() { return cProductKeyword_5; }
	}

	public class StringRopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringRop");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// Relational Operation for Strings
		//StringRop:
		//	"==" | "!=";
		public ParserRule getRule() { return rule; }

		//"==" | "!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_0() { return cEqualsSignEqualsSignKeyword_0; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1() { return cExclamationMarkEqualsSignKeyword_1; }
	}

	public class RopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Rop");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringRopParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//// Relational Operation
		//Rop:
		//	StringRop | "<" | "<=" | ">" | ">=";
		public ParserRule getRule() { return rule; }

		//StringRop | "<" | "<=" | ">" | ">="
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringRop
		public RuleCall getStringRopParserRuleCall_0() { return cStringRopParserRuleCall_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_2() { return cLessThanSignEqualsSignKeyword_2; }

		//">"
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_4() { return cGreaterThanSignEqualsSignKeyword_4; }
	}
	
	
	private ModelElements pModel;
	private DeclarationElements pDeclaration;
	private AssertionOrElements pAssertionOr;
	private AssertionAndElements pAssertionAnd;
	private AssertionHPElements pAssertionHP;
	private AssertionBracedElements pAssertionBraced;
	private AssertionNotElements pAssertionNot;
	private AssertionFormElements pAssertionForm;
	private AssertionStdCmpElements pAssertionStdCmp;
	private AssertionElements pAssertion;
	private AssertionBooleanElements pAssertionBoolean;
	private AssertionQuantifiedBooleanElements pAssertionQuantifiedBoolean;
	private AssertionQuantifiedNumericElements pAssertionQuantifiedNumeric;
	private StepElements pStep;
	private AttributeElements pAttribute;
	private FunctionElements pFunction;
	private FunctionBooleanElements pFunctionBoolean;
	private ValuesElements pValues;
	private ValueElements pValue;
	private ConstantElements pConstant;
	private VariableElements pVariable;
	private BoolQuantifierElements pBoolQuantifier;
	private NumbQuantifierElements pNumbQuantifier;
	private StringRopElements pStringRop;
	private RopElements pRop;
	private TerminalRule tBOOLEAN;
	private TerminalRule tNUMBER;
	private TerminalRule tINT;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public XptGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.xpt.Xpt".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	declarations+=Declaration* assertionSet=AssertionOr ";";
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//// Assign to the variable a value (a String, Double, Boolean or SDO)
	//Declaration:
	//	"let" var=Variable "=" assert=(Assertion | AssertionQuantifiedBoolean) ";";
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//// Assertion results in logical operation OR
	//AssertionOr returns Assertions:
	//	AssertionAnd ({AssertionOr.left=current} "||" right=AssertionAnd)*;
	public AssertionOrElements getAssertionOrAccess() {
		return (pAssertionOr != null) ? pAssertionOr : (pAssertionOr = new AssertionOrElements());
	}
	
	public ParserRule getAssertionOrRule() {
		return getAssertionOrAccess().getRule();
	}

	//// Assertion results in logical operation AND
	//AssertionAnd returns Assertions:
	//	AssertionHP ({AssertionAnd.left=current} "&&" right=AssertionHP)*;
	public AssertionAndElements getAssertionAndAccess() {
		return (pAssertionAnd != null) ? pAssertionAnd : (pAssertionAnd = new AssertionAndElements());
	}
	
	public ParserRule getAssertionAndRule() {
		return getAssertionAndAccess().getRule();
	}

	//// Assertion results in logical operation with highest priority (NOT and parentheses)
	//AssertionHP returns Assertions:
	//	AssertionNot | AssertionBraced | AssertionForm;
	public AssertionHPElements getAssertionHPAccess() {
		return (pAssertionHP != null) ? pAssertionHP : (pAssertionHP = new AssertionHPElements());
	}
	
	public ParserRule getAssertionHPRule() {
		return getAssertionHPAccess().getRule();
	}

	//// Assertion with parentheses
	//AssertionBraced:
	//	"(" innerFormula=AssertionOr ")";
	public AssertionBracedElements getAssertionBracedAccess() {
		return (pAssertionBraced != null) ? pAssertionBraced : (pAssertionBraced = new AssertionBracedElements());
	}
	
	public ParserRule getAssertionBracedRule() {
		return getAssertionBracedAccess().getRule();
	}

	//// Assertion with logical operator NOT
	//AssertionNot:
	//	"!" "(" innerFormula=AssertionOr ")";
	public AssertionNotElements getAssertionNotAccess() {
		return (pAssertionNot != null) ? pAssertionNot : (pAssertionNot = new AssertionNotElements());
	}
	
	public ParserRule getAssertionNotRule() {
		return getAssertionNotAccess().getRule();
	}

	//// Kinds of Assertion: with comparison and without (2nd and 3rd case are for boolean comparison and their result is implicitly 'true')
	//AssertionForm:
	//	AssertionStdCmp | AssertionQuantifiedBoolean | AssertionBoolean;
	public AssertionFormElements getAssertionFormAccess() {
		return (pAssertionForm != null) ? pAssertionForm : (pAssertionForm = new AssertionFormElements());
	}
	
	public ParserRule getAssertionFormRule() {
		return getAssertionFormAccess().getRule();
	}

	//// Assertions making a standard comparison between values
	//AssertionStdCmp:
	//	leftAssert=Assertion op=Rop rightAssert=Assertion;
	public AssertionStdCmpElements getAssertionStdCmpAccess() {
		return (pAssertionStdCmp != null) ? pAssertionStdCmp : (pAssertionStdCmp = new AssertionStdCmpElements());
	}
	
	public ParserRule getAssertionStdCmpRule() {
		return getAssertionStdCmpAccess().getRule();
	}

	//// Assertion
	//Assertion:
	//	steps+=Step+ ("." functions+=Function)* | AssertionQuantifiedNumeric | "[" values=Values "]" | constant=Constant;
	public AssertionElements getAssertionAccess() {
		return (pAssertion != null) ? pAssertion : (pAssertion = new AssertionElements());
	}
	
	public ParserRule getAssertionRule() {
		return getAssertionAccess().getRule();
	}

	//// Assertion with boolean result
	//AssertionBoolean returns Assertion:
	//	steps+=Step+ ("." functions+=Function)* "." functions+=FunctionBoolean;
	public AssertionBooleanElements getAssertionBooleanAccess() {
		return (pAssertionBoolean != null) ? pAssertionBoolean : (pAssertionBoolean = new AssertionBooleanElements());
	}
	
	public ParserRule getAssertionBooleanRule() {
		return getAssertionBooleanAccess().getRule();
	}

	//// Assertion with quantifiers for boolean results
	//AssertionQuantifiedBoolean returns AssertionQuantified:
	//	quantifier=BoolQuantifier "(" alias=Variable "in" var=Variable "," conditions=AssertionOr ")";
	public AssertionQuantifiedBooleanElements getAssertionQuantifiedBooleanAccess() {
		return (pAssertionQuantifiedBoolean != null) ? pAssertionQuantifiedBoolean : (pAssertionQuantifiedBoolean = new AssertionQuantifiedBooleanElements());
	}
	
	public ParserRule getAssertionQuantifiedBooleanRule() {
		return getAssertionQuantifiedBooleanAccess().getRule();
	}

	//// Assertion with quantifiers for numeric results
	//AssertionQuantifiedNumeric returns AssertionQuantified:
	//	quantifier=NumbQuantifier "(" alias=Variable "in" var=Variable "," conditions=AssertionOr ")";
	public AssertionQuantifiedNumericElements getAssertionQuantifiedNumericAccess() {
		return (pAssertionQuantifiedNumeric != null) ? pAssertionQuantifiedNumeric : (pAssertionQuantifiedNumeric = new AssertionQuantifiedNumericElements());
	}
	
	public ParserRule getAssertionQuantifiedNumericRule() {
		return getAssertionQuantifiedNumericAccess().getRule();
	}

	//// Steps describing the navigation path through an SDO
	//Step:
	//	"/" name=ID ("[" attribute=Attribute "]")? | placeholder=Variable;
	public StepElements getStepAccess() {
		return (pStep != null) ? pStep : (pStep = new StepElements());
	}
	
	public ParserRule getStepRule() {
		return getStepAccess().getRule();
	}

	//// Attribute for SDO navigation: according to the operation checks the searched value, if possible
	//Attribute:
	//	property=ID (op=Rop numberValue=NUMBER | op=StringRop strValue=STRING | op=Rop varValue=Variable) | number=NUMBER |
	//	var=Variable;
	public AttributeElements getAttributeAccess() {
		return (pAttribute != null) ? pAttribute : (pAttribute = new AttributeElements());
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//// Function
	//Function:
	//	name=ID "(" params=Values? ")";
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//// Function that gives boolean result
	//FunctionBoolean returns Function:
	//	name=("contains" | "startsWith" | "endsWith") "(" params=Values? ")";
	public FunctionBooleanElements getFunctionBooleanAccess() {
		return (pFunctionBoolean != null) ? pFunctionBoolean : (pFunctionBoolean = new FunctionBooleanElements());
	}
	
	public ParserRule getFunctionBooleanRule() {
		return getFunctionBooleanAccess().getRule();
	}

	//// List of values
	//Values:
	//	value+=Value ("," value+=Value)*;
	public ValuesElements getValuesAccess() {
		return (pValues != null) ? pValues : (pValues = new ValuesElements());
	}
	
	public ParserRule getValuesRule() {
		return getValuesAccess().getRule();
	}

	//// Value could be a constant (alphanumeric or numeric) or obtained by an SDO's property
	//Value:
	//	Constant | steps+=Step+ ("." functions+=Function)*;
	public ValueElements getValueAccess() {
		return (pValue != null) ? pValue : (pValue = new ValueElements());
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//Constant:
	//	number=NUMBER | string=STRING;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//// Variable (NumbQuantifier is added for give the possibility to use 'max', 'min', etc. as variables name)
	//Variable:
	//	"$" (ID | NumbQuantifier);
	public VariableElements getVariableAccess() {
		return (pVariable != null) ? pVariable : (pVariable = new VariableElements());
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//BoolQuantifier:
	//	"forall" | "exists";
	public BoolQuantifierElements getBoolQuantifierAccess() {
		return (pBoolQuantifier != null) ? pBoolQuantifier : (pBoolQuantifier = new BoolQuantifierElements());
	}
	
	public ParserRule getBoolQuantifierRule() {
		return getBoolQuantifierAccess().getRule();
	}

	//NumbQuantifier:
	//	"numOf" | "sum" | "avg" | "min" | "max" | "product";
	public NumbQuantifierElements getNumbQuantifierAccess() {
		return (pNumbQuantifier != null) ? pNumbQuantifier : (pNumbQuantifier = new NumbQuantifierElements());
	}
	
	public ParserRule getNumbQuantifierRule() {
		return getNumbQuantifierAccess().getRule();
	}

	//// Relational Operation for Strings
	//StringRop:
	//	"==" | "!=";
	public StringRopElements getStringRopAccess() {
		return (pStringRop != null) ? pStringRop : (pStringRop = new StringRopElements());
	}
	
	public ParserRule getStringRopRule() {
		return getStringRopAccess().getRule();
	}

	//// Relational Operation
	//Rop:
	//	StringRop | "<" | "<=" | ">" | ">=";
	public RopElements getRopAccess() {
		return (pRop != null) ? pRop : (pRop = new RopElements());
	}
	
	public ParserRule getRopRule() {
		return getRopAccess().getRule();
	}

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false" | "TRUE" | "FALSE";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal NUMBER returns ecore::EDouble:
	//	"-"? "0".."9"* ("." "0".."9"+)?;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//// override della regola di default
	//terminal INT returns ecore::EInt:
	//	"this one has been deactivated";
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
